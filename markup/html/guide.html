
<div class="guide-wrap">
  <svg class="guide-svg" width="100%" height="100%">
    <defs>
      <mask id="guide-mask">
        <rect x="0" y="0" width="100%" height="100%" fill="white" />
        <path id="guide-cutout-path" fill="black" />
      </mask>
    </defs>
    <rect
      x="0"
      y="0"
      width="100%"
      height="100%"
      fill="rgba(0, 0, 0, 0.5)"
      mask="url(#guide-mask)"
    />
  </svg>

  <div class="guide-mask nav"></div>
  <div class="guide-mask"></div>
</div>
<script>
  class MultiGuide {
    constructor(targets) {
      this.targets = targets;
      this.isActive = false;
      this.init();
    }

    init() {
      console.log("[MultiGuide.init] ì´ˆê¸°í™” ì‹œì‘");
      
      this.guideWrap = document.querySelector(".guide-wrap");
      console.log("[MultiGuide.init] guideWrap:", this.guideWrap);
      
      if (!this.guideWrap) {
        console.error("[MultiGuide.init] âŒ .guide-wrap ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
        // ì¬ì‹œë„
        setTimeout(() => {
          this.guideWrap = document.querySelector(".guide-wrap");
          if (this.guideWrap) {
            console.log("[MultiGuide.init] âœ… ì¬ì‹œë„ í›„ guideWrap ì°¾ìŒ");
            this.continueInit();
          } else {
            console.error("[MultiGuide.init] âŒ ì¬ì‹œë„ ì‹¤íŒ¨");
          }
        }, 100);
        return;
      }
      
      this.continueInit();
    }
    
    continueInit() {
      this.cutoutPath = document.getElementById("guide-cutout-path");
      console.log("[MultiGuide.init] cutoutPath:", this.cutoutPath);
      
      this.bordersContainer = document.getElementById("guideBorders");
      this.labelsContainer = document.getElementById("guideLabels");

      if (!this.bordersContainer) {
        this.bordersContainer = document.createElement("div");
        this.bordersContainer.id = "guideBorders";
        this.bordersContainer.className = "guide-borders";
        this.guideWrap.appendChild(this.bordersContainer);
        console.log("[MultiGuide.init] bordersContainer ìƒì„±ë¨");
      }

      if (!this.labelsContainer) {
        this.labelsContainer = document.createElement("div");
        this.labelsContainer.id = "guideLabels";
        this.labelsContainer.className = "guide-labels";
        this.labelsContainer.style.cssText =
          "position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10000;";
        this.guideWrap.appendChild(this.labelsContainer);
        console.log("[MultiGuide.init] labelsContainer ìƒì„±ë¨");
      }

      this.attachEvents();
      console.log("[MultiGuide.init] âœ… ì´ˆê¸°í™” ì™„ë£Œ");
    }

    getStartButton() {
      return (
        document.querySelector(".guide-start-btn") ||
        document.getElementById("guideStart") ||
        document.querySelector("[data-guide-start]")
      );
    }

    attachEvents() {
      const startBtn = this.getStartButton();
      if (startBtn) {
        startBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.show();
        });
      }

      const svg = document.querySelector(".guide-svg");
      if (svg) {
        svg.addEventListener("click", (e) => {
          if (e.target === svg || e.target.tagName.toLowerCase() === "rect") {
            this.hide();
          }
        });
      }

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && this.isActive) {
          this.hide();
        }
      });
    }

    show() {
      console.log("[MultiGuide.show] ê°€ì´ë“œ í‘œì‹œ ì‹œì‘");
      console.log("[MultiGuide.show] guideWrap ìš”ì†Œ:", this.guideWrap);
      
      if (!this.guideWrap) {
        console.error("[MultiGuide.show] âŒ guideWrapì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
        return;
      }

      this.isActive = true;
      this.guideWrap.classList.add("active");
      console.log("[MultiGuide.show] active í´ë˜ìŠ¤ ì¶”ê°€ë¨. í´ë˜ìŠ¤ ëª©ë¡:", this.guideWrap.className);

      const startBtn = this.getStartButton();
      if (startBtn) startBtn.style.display = "none";

      document.body.style.overflow = "hidden";

      console.log("[MultiGuide.show] cutouts ìƒì„± ì¤‘...");
      this.createCutouts();
      
      console.log("[MultiGuide.show] borders ìƒì„± ì¤‘...");
      this.createBorders();
      
      console.log("[MultiGuide.show] labels ìƒì„± ì¤‘...");
      this.createLabels();
      
      console.log("[MultiGuide.show] âœ… ê°€ì´ë“œ í‘œì‹œ ì™„ë£Œ");
      
      // DOM í™•ì¸
      setTimeout(() => {
        const computedStyle = window.getComputedStyle(this.guideWrap);
        console.log("[MultiGuide.show] ìµœì¢… í™•ì¸:", {
          display: computedStyle.display,
          opacity: computedStyle.opacity,
          visibility: computedStyle.visibility,
          hasActiveClass: this.guideWrap.classList.contains("active")
        });
      }, 100);
    }

    hide() {
      this.isActive = false;
      this.guideWrap.classList.remove("active");

      const startBtn = this.getStartButton();
      if (startBtn) startBtn.style.display = "block";

      document.body.style.overflow = "";

      if (this.bordersContainer) this.bordersContainer.innerHTML = "";
      if (this.labelsContainer) this.labelsContainer.innerHTML = "";
    }

    createCutouts() {
      let pathData = "";

      this.targets.forEach((target) => {
        const element = document.querySelector(target.selector);
        if (!element) {
          console.warn("ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:", target.selector);
          return;
        }

        // gauge SVGë¥¼ ê¸°ë°˜ìœ¼ë¡œ arc ê·¸ë¦¬ê¸°
        if (target.useGaugeArc) {
          pathData += this.createGaugeArcPath(element, target) + " ";
        }
        // ì¼ë°˜ arc
        else if (target.shape === "arc") {
          pathData +=
            this.createArcPath(
              element.getBoundingClientRect(),
              target.padding || 15,
              target
            ) + " ";
        }
        // ê¸°ë³¸ ì‚¬ê°í˜•
        else {
          const rect = element.getBoundingClientRect();
          const padding = target.padding || 15;
          const radius = target.borderRadius || 12;
          pathData +=
            this.createRoundedRectPath(
              rect.left - padding,
              rect.top - padding,
              rect.width + padding * 2,
              rect.height + padding * 2,
              radius
            ) + " ";
        }
      });

      this.cutoutPath.setAttribute("d", pathData.trim());
    }

    // ì‹¤ì œ ê²Œì´ì§€ ì„¤ì •ê°’ì„ ì‚¬ìš©í•œ arc path
    createGaugeArcPath(containerElement, target) {
      // gauge SVG ì°¾ê¸°
      const gaugeSvg = document.getElementById("gauge");
      if (!gaugeSvg) {
        console.warn("gauge SVGë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        return this.createArcPath(
          containerElement.getBoundingClientRect(),
          target.padding || 15,
          target
        );
      }

      // ê²Œì´ì§€ ì„¤ì •ê°’ (gauge.jsì™€ ë™ì¼)
      const size = target.gaugeSize || 832;
      const strokeWidth = target.gaugeStrokeWidth || 31;
      const padding = target.gaugePadding || 20;

      // ì‹¤ì œ ë°˜ì§€ë¦„ ê³„ì‚° (gauge.jsì™€ ë™ì¼)
      const center = size / 2;
      const radius = size / 2 - strokeWidth / 2 - padding;

      // SVGì˜ í™”ë©´ìƒ ìœ„ì¹˜ì™€ í¬ê¸°
      const svgRect = gaugeSvg.getBoundingClientRect();

      // viewBox ì •ë³´
      const viewBox = gaugeSvg.viewBox.baseVal;
      const viewBoxWidth = viewBox.width;
      const viewBoxHeight = viewBox.height;

      // ìŠ¤ì¼€ì¼ ê³„ì‚°
      const scaleX = svgRect.width / viewBoxWidth;
      const scaleY = svgRect.height / viewBoxHeight;

      // ì¤‘ì‹¬ì  í™”ë©´ ì¢Œí‘œ ë³€í™˜
      const screenCenterX = svgRect.left + (center - viewBox.x) * scaleX;
      const screenCenterY = svgRect.top + (center - viewBox.y) * scaleY;

      // ë°˜ì§€ë¦„ í™”ë©´ ì¢Œí‘œ ë³€í™˜
      const screenRadius = radius * scaleX;
      const screenStrokeWidth = strokeWidth * scaleX;

      // arcì˜ ë‘ê»˜ (stroke + ì—¬ìœ )
      const arcThickness = screenStrokeWidth + (target.padding || 10) * 2;

      // ê°ë„ ì„¤ì • (ê¸°ë³¸: í•˜ë‹¨ ë°˜ì›)
      const startAngle = target.startAngle || 180;
      const endAngle = target.endAngle || 360;

      // ì™¸ë¶€/ë‚´ë¶€ ë°˜ì§€ë¦„
      const outerRadius = screenRadius + arcThickness / 2;
      const innerRadius = screenRadius - arcThickness / 2;

      // ê°ë„ë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ
      const startRad = (startAngle * Math.PI) / 180;
      const endRad = (endAngle * Math.PI) / 180;

      // ì™¸ë¶€ arc ì ë“¤
      const outerStartX = screenCenterX + outerRadius * Math.cos(startRad);
      const outerStartY = screenCenterY + outerRadius * Math.sin(startRad);
      const outerEndX = screenCenterX + outerRadius * Math.cos(endRad);
      const outerEndY = screenCenterY + outerRadius * Math.sin(endRad);

      // ë‚´ë¶€ arc ì ë“¤
      const innerStartX = screenCenterX + innerRadius * Math.cos(startRad);
      const innerStartY = screenCenterY + innerRadius * Math.sin(startRad);
      const innerEndX = screenCenterX + innerRadius * Math.cos(endRad);
      const innerEndY = screenCenterY + innerRadius * Math.sin(endRad);

      const largeArc = endAngle - startAngle > 180 ? 1 : 0;

      // ğŸ”¥ ë‘¥ê·¼ ëì„ ìœ„í•œ ë°˜ì§€ë¦„ (arc ë‘ê»˜ì˜ ì ˆë°˜)
      const capRadius = arcThickness / 2;

      // ë„ë„› ëª¨ì–‘ path + ì–‘ìª½ ëì— ì› ì¶”ê°€
      let pathData = `
        M ${outerStartX},${outerStartY}
        A ${outerRadius},${outerRadius} 0 ${largeArc} 1 ${outerEndX},${outerEndY}
        L ${innerEndX},${innerEndY}
        A ${innerRadius},${innerRadius} 0 ${largeArc} 0 ${innerStartX},${innerStartY}
        Z
      `;

      // ì‹œì‘ì  ë‘¥ê·¼ ìº¡ (ì›)
      const startCapCenterX = screenCenterX + screenRadius * Math.cos(startRad);
      const startCapCenterY = screenCenterY + screenRadius * Math.sin(startRad);
      pathData += `
        M ${startCapCenterX + capRadius},${startCapCenterY}
        A ${capRadius},${capRadius} 0 1 1 ${startCapCenterX - capRadius},${startCapCenterY}
        A ${capRadius},${capRadius} 0 1 1 ${startCapCenterX + capRadius},${startCapCenterY}
        Z
      `;

      // ëì  ë‘¥ê·¼ ìº¡ (ì›)
      const endCapCenterX = screenCenterX + screenRadius * Math.cos(endRad);
      const endCapCenterY = screenCenterY + screenRadius * Math.sin(endRad);
      pathData += `
        M ${endCapCenterX + capRadius},${endCapCenterY}
        A ${capRadius},${capRadius} 0 1 1 ${endCapCenterX - capRadius},${endCapCenterY}
        A ${capRadius},${capRadius} 0 1 1 ${endCapCenterX + capRadius},${endCapCenterY}
        Z
      `;

      return pathData;
    }

    // ì¼ë°˜ arc path (fallback)
    createArcPath(rect, padding, target) {
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const radius = rect.width / 2 + padding;
      const thickness = target.arcThickness || radius * 0.2;
      const startAngle = target.startAngle || 180;
      const endAngle = target.endAngle || 360;

      const outerRadius = radius;
      const innerRadius = radius - thickness;

      const startRad = (startAngle * Math.PI) / 180;
      const endRad = (endAngle * Math.PI) / 180;

      const outerStartX = centerX + outerRadius * Math.cos(startRad);
      const outerStartY = centerY + outerRadius * Math.sin(startRad);
      const outerEndX = centerX + outerRadius * Math.cos(endRad);
      const outerEndY = centerY + outerRadius * Math.sin(endRad);

      const innerStartX = centerX + innerRadius * Math.cos(startRad);
      const innerStartY = centerY + innerRadius * Math.sin(startRad);
      const innerEndX = centerX + innerRadius * Math.cos(endRad);
      const innerEndY = centerY + innerRadius * Math.sin(endRad);

      const largeArc = endAngle - startAngle > 180 ? 1 : 0;

      // ğŸ”¥ ë‘¥ê·¼ ëì„ ìœ„í•œ ë°˜ì§€ë¦„
      const capRadius = thickness / 2;

      // ë„ë„› ëª¨ì–‘ + ì–‘ìª½ ë ì›
      let pathData = `
        M ${outerStartX},${outerStartY}
        A ${outerRadius},${outerRadius} 0 ${largeArc} 1 ${outerEndX},${outerEndY}
        L ${innerEndX},${innerEndY}
        A ${innerRadius},${innerRadius} 0 ${largeArc} 0 ${innerStartX},${innerStartY}
        Z
      `;

      // ì‹œì‘ì  ë‘¥ê·¼ ìº¡
      const startCapX =
        centerX + (outerRadius - thickness / 2) * Math.cos(startRad);
      const startCapY =
        centerY + (outerRadius - thickness / 2) * Math.sin(startRad);
      pathData += `
        M ${startCapX + capRadius},${startCapY}
        A ${capRadius},${capRadius} 0 1 1 ${startCapX - capRadius},${startCapY}
        A ${capRadius},${capRadius} 0 1 1 ${startCapX + capRadius},${startCapY}
        Z
      `;

      // ëì  ë‘¥ê·¼ ìº¡
      const endCapX =
        centerX + (outerRadius - thickness / 2) * Math.cos(endRad);
      const endCapY =
        centerY + (outerRadius - thickness / 2) * Math.sin(endRad);
      pathData += `
        M ${endCapX + capRadius},${endCapY}
        A ${capRadius},${capRadius} 0 1 1 ${endCapX - capRadius},${endCapY}
        A ${capRadius},${capRadius} 0 1 1 ${endCapX + capRadius},${endCapY}
        Z
      `;

      return pathData;
    }

    createRoundedRectPath(x, y, width, height, radius) {
      return `
        M ${x + radius},${y}
        L ${x + width - radius},${y}
        Q ${x + width},${y} ${x + width},${y + radius}
        L ${x + width},${y + height - radius}
        Q ${x + width},${y + height} ${x + width - radius},${y + height}
        L ${x + radius},${y + height}
        Q ${x},${y + height} ${x},${y + height - radius}
        L ${x},${y + radius}
        Q ${x},${y} ${x + radius},${y}
        Z
      `;
    }

    createBorders() {
      this.targets.forEach((target, index) => {
        const element = document.querySelector(target.selector);
        if (!element) return;

        // arcëŠ” SVG borderë¡œ ê·¸ë¦¬ê¸°
        if (target.useGaugeArc || target.shape === "arc") {
          // this.createArcBorder(element, target, index);
          return;
        }

        // ì¼ë°˜ ìš”ì†Œë§Œ div border í‘œì‹œ
        const rect = element.getBoundingClientRect();
        const padding = target.padding || 15;

        const border = document.createElement("div");
        border.className = "guide-border";
        border.style.cssText = `
          left: ${rect.left - padding}px;
          top: ${rect.top - padding}px;
          width: ${rect.width + padding * 2}px;
          height: ${rect.height + padding * 2}px;
          animation-delay: ${index * 0.1}s;
        `;
        this.bordersContainer.appendChild(border);
      });
    }

    // arc ì „ìš© SVG ë³´ë”
    createArcBorder(element, target, index) {
      const gaugeSvg = document.getElementById("gauge");
      if (!gaugeSvg && !target.useGaugeArc) {
        return;
      }

      let screenCenterX, screenCenterY, screenRadius, arcThickness;

      if (gaugeSvg && target.useGaugeArc) {
        // ì‹¤ì œ ê²Œì´ì§€ ì„¤ì • ì‚¬ìš©
        const size = target.gaugeSize || 832;
        const strokeWidth = target.gaugeStrokeWidth || 31;
        const padding = target.gaugePadding || 20;

        const center = size / 2;
        const gaugeRadius = size / 2 - strokeWidth / 2 - padding;

        const svgRect = gaugeSvg.getBoundingClientRect();
        const viewBox = gaugeSvg.viewBox.baseVal;
        const scaleX = svgRect.width / viewBox.width;

        screenCenterX = svgRect.left + (center - viewBox.x) * scaleX;
        screenCenterY = svgRect.top + (center - viewBox.y) * scaleX;
        screenRadius = gaugeRadius * scaleX;
        const screenStrokeWidth = strokeWidth * scaleX;
        arcThickness = screenStrokeWidth + (target.padding || 10) * 2;
      } else {
        // fallback
        const rect = element.getBoundingClientRect();
        screenCenterX = rect.left + rect.width / 2;
        screenCenterY = rect.top + rect.height / 2;
        screenRadius = rect.width / 2;
        arcThickness = target.arcThickness || screenRadius * 0.2;
      }

      const startAngle = target.startAngle || 180;
      const endAngle = target.endAngle || 360;

      const outerRadius = screenRadius + arcThickness / 2;
      const innerRadius = screenRadius - arcThickness / 2;

      const startRad = (startAngle * Math.PI) / 180;
      const endRad = (endAngle * Math.PI) / 180;

      const outerStartX = screenCenterX + outerRadius * Math.cos(startRad);
      const outerStartY = screenCenterY + outerRadius * Math.sin(startRad);
      const outerEndX = screenCenterX + outerRadius * Math.cos(endRad);
      const outerEndY = screenCenterY + outerRadius * Math.sin(endRad);

      const innerStartX = screenCenterX + innerRadius * Math.cos(startRad);
      const innerStartY = screenCenterY + innerRadius * Math.sin(startRad);
      const innerEndX = screenCenterX + innerRadius * Math.cos(endRad);
      const innerEndY = screenCenterY + innerRadius * Math.sin(endRad);

      const largeArc = endAngle - startAngle > 180 ? 1 : 0;

      // SVG ìƒì„±
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.style.cssText = `
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      `;

      // ì™¸ë¶€ arc
      const outerArc = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const outerArcData = `
        M ${outerStartX},${outerStartY}
        A ${outerRadius},${outerRadius} 0 ${largeArc} 1 ${outerEndX},${outerEndY}
      `;
      outerArc.setAttribute("d", outerArcData);
      outerArc.setAttribute("fill", "none");
      outerArc.setAttribute("stroke", "#4A9EFF");
      outerArc.setAttribute("stroke-width", "3");

      // ë‚´ë¶€ arc
      const innerArc = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const innerArcData = `
        M ${innerStartX},${innerStartY}
        A ${innerRadius},${innerRadius} 0 ${largeArc} 1 ${innerEndX},${innerEndY}
      `;
      innerArc.setAttribute("d", innerArcData);
      innerArc.setAttribute("fill", "none");
      innerArc.setAttribute("stroke", "#4A9EFF");
      innerArc.setAttribute("stroke-width", "3");

      // ì‹œì‘ìª½ ë°˜ì› ìº¡ (ì±„ì›Œì§„ ì›)
      const startCapRadius = arcThickness / 2;
      const startCapCenterX = screenCenterX + screenRadius * Math.cos(startRad);
      const startCapCenterY = screenCenterY + screenRadius * Math.sin(startRad);

      const startCap = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle"
      );
      startCap.setAttribute("cx", startCapCenterX);
      startCap.setAttribute("cy", startCapCenterY);
      startCap.setAttribute("r", startCapRadius);
      startCap.setAttribute("fill", "#4A9EFF");
      startCap.setAttribute("stroke", "#4A9EFF");
      startCap.setAttribute("stroke-width", "3");

      // ëìª½ ë°˜ì› ìº¡ (ì±„ì›Œì§„ ì›)
      const endCapCenterX = screenCenterX + screenRadius * Math.cos(endRad);
      const endCapCenterY = screenCenterY + screenRadius * Math.sin(endRad);

      const endCap = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle"
      );
      endCap.setAttribute("cx", endCapCenterX);
      endCap.setAttribute("cy", endCapCenterY);
      endCap.setAttribute("r", startCapRadius);
      endCap.setAttribute("fill", "#4A9EFF");
      endCap.setAttribute("stroke", "#4A9EFF");
      endCap.setAttribute("stroke-width", "3");

      svg.appendChild(outerArc);
      svg.appendChild(innerArc);
      svg.appendChild(startCap);
      svg.appendChild(endCap);
      this.bordersContainer.appendChild(svg);
    }

    createLabels() {
      this.targets.forEach((target, index) => {
        if (!target.label) return;

        const element = document.querySelector(target.selector);
        if (!element) return;

        const rect = element.getBoundingClientRect();

        // ì„¤ëª… ë°•ìŠ¤ ìƒì„±
        const tooltipBox = document.createElement("div");
        tooltipBox.className = "guide-tooltip-box";
        tooltipBox.style.cssText = `
          position: fixed;
          background: white;
          border: 2px solid #000;
          border-radius: 8px;
          padding: 16px 20px;
          //max-width: 300px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          z-index: 10001;
          pointer-events: auto;
          animation: tooltipFadeIn 0.4s ease-out ${index * 0.1 + 0.3}s forwards;
          opacity: 0;
        `;

        // ì œëª©
        const title = document.createElement("div");
        title.className = "guide-tooltip-title";
        title.textContent = target.label;
        title.style.cssText = `
          font-weight: bold;
          font-size: 16px;
          margin-bottom: ${target.description ? '8px' : '0'};
          color: #000;
        `;
        tooltipBox.appendChild(title);

        // ì„¤ëª… (ìˆëŠ” ê²½ìš°)
        if (target.description) {
          const description = document.createElement("div");
          description.className = "guide-tooltip-description";
          // ì¤„ë°”ê¿ˆ ì²˜ë¦¬
          const lines = target.description.split('\n');
          lines.forEach((line, idx) => {
            if (idx > 0) {
              description.appendChild(document.createElement("br"));
            }
            description.appendChild(document.createTextNode(line));
          });
          description.style.cssText = `
            font-size: 14px;
            line-height: 1.5;
            color: #666;
            white-space: pre-line;
          `;
          tooltipBox.appendChild(description);
        }

        // ë¨¼ì € DOMì— ì¶”ê°€í•´ì„œ ë†’ì´ ì¸¡ì •
        this.labelsContainer.appendChild(tooltipBox);
        
        // ìœ„ì¹˜ ê³„ì‚° (ìš”ì†Œ ê·¼ì²˜ì— ë°°ì¹˜)
        let left = rect.left + rect.width / 2;
        let top = rect.top - 10;

        // ìš”ì†Œ ìœ„ìª½ì— ë°°ì¹˜ (ê³µê°„ì´ ë¶€ì¡±í•˜ë©´ ì•„ë˜ìª½)
        if (target.position === "bottom" || (rect.top < 150 && target.position !== "top")) {
          top = rect.bottom + 15;
        } else {
          const boxHeight = tooltipBox.offsetHeight || 100;
          top = rect.top - boxHeight - 15;
          if (top < 10) {
            top = rect.bottom + 15;
          }
        }

        // ì¢Œìš° ì •ë ¬
        if (target.position === "left") {
          left = rect.left - 10;
          tooltipBox.setAttribute("data-position", "left");
          tooltipBox.style.transform = "translateX(-100%)";
        } else if (target.position === "right") {
          left = rect.right + 10;
          tooltipBox.setAttribute("data-position", "right");
          tooltipBox.style.transform = "translateX(0)";
        } else {
          tooltipBox.style.transform = "translateX(-50%)";
        }

        tooltipBox.style.left = `${left}px`;
        tooltipBox.style.top = `${top}px`;
      });

      // ì• ë‹ˆë©”ì´ì…˜ ìŠ¤íƒ€ì¼ ì¶”ê°€
      if (!document.getElementById("guide-tooltip-styles")) {
        const style = document.createElement("style");
        style.id = "guide-tooltip-styles";
        style.textContent = `
          @keyframes tooltipFadeIn {
            from {
              opacity: 0;
              transform: translateY(-10px);
            }
            to {
              opacity: 1;
              transform: translateY(0);
            }
          }
          .guide-tooltip-box[data-position="left"] {
            animation-name: tooltipFadeInLeft;
          }
          .guide-tooltip-box[data-position="right"] {
            animation-name: tooltipFadeInRight;
          }
          @keyframes tooltipFadeInLeft {
            from {
              opacity: 0;
              transform: translateX(-100%) translateY(-10px);
            }
            to {
              opacity: 1;
              transform: translateX(-100%) translateY(0);
            }
          }
          @keyframes tooltipFadeInRight {
            from {
              opacity: 0;
              transform: translateX(0) translateY(-10px);
            }
            to {
              opacity: 1;
              transform: translateX(0) translateY(0);
            }
          }
        `;
        document.head.appendChild(style);
      }
    }
  }

  // ============================================
  // íƒ€ê²Ÿ ì„¤ì • - ì‹¤ì œ ê²Œì´ì§€ ì„¤ì • ë°˜ì˜
  // ============================================
  const guideTargets = [
    {
      selector: ".guide-mask",
      padding: 0,
      borderRadius: 8,
      label: "ë©”ë‰´",
      description: "ë§ˆì´í´ë˜ìŠ¤ : ë¶„ê¸°ë³„ ì—…ë°ì´íŠ¸ ë˜ëŠ” ê¶Œì¥ í•™ìŠµ\nì˜¨ë³´ë”©/ë²•ì •êµìœ¡ : ì •í•´ì§„ ê¸°ê°„ ë‚´ ì´ìˆ˜í•´ì•¼ í•˜ëŠ” í•„ìˆ˜ êµìœ¡\në¦¬ë”ì‹­/ì¸ì‚¬ì´íŠ¸/ë¹„ì¦ˆíŠ¸ë Œë“œ : ì§€ì†ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ë˜ëŠ” ììœ¨ í•™ìŠµ",
      position: "bottom",
    },
    {
      selector: ".input-group",
      padding: 0,
      borderRadius: 12,
      label: "ê²€ìƒ‰",
      description: "2ê°œ ë‹¨ì–´ ì´ìƒ ê²€ìƒ‰ ì‹œ ë„ì–´ì“°ê¸°ë¡œ êµ¬ë¶„í•´ ê²€ìƒ‰",
      position: "bottom",
    },
    {
      selector: ".item-box:first-of-type",
      padding: 0,
      borderRadius: 8,
      label: "ê³µì§€ì‚¬í•­",
      description: "ì¤‘ìš”í•œ ê³µì§€Â·ì•Œë¦¼ í™•ì¸",
      position: "bottom",
    },
    {
      selector: ".item-box:last-of-type, .mypage",
      padding: 0,
      borderRadius: 8,
      label: "ë§ˆì´í˜ì´ì§€",
      description: "ë‚˜ì˜ í•™ìŠµí˜„í™©Â·ìµœê·¼ ì‹œì²­Â·ì €ì¥í•œ ì½˜í…ì¸ Â·í•œ ì¤„ì†Œê°ì„ í•œëˆˆì— í™•ì¸",
      position: "bottom",
    },
    // ===== ì‹¤ì œ ê²Œì´ì§€ ì„¤ì •ì„ ì‚¬ìš©í•œ ì •í™•í•œ arc! =====
    {
      selector: ".learning-area", // ë˜ëŠ” gaugeì˜ ë¶€ëª¨ ì»¨í…Œì´ë„ˆ
      useGaugeArc: true, // ğŸ”¥ ì‹¤ì œ ê²Œì´ì§€ ì„¤ì • ì‚¬ìš©!
      gaugeSize: 832, // gauge.jsì˜ size
      gaugeStrokeWidth: 31, // gauge.jsì˜ strokeWidth
      gaugePadding: 20, // gauge.jsì˜ padding
      padding: 10, // ì¶”ê°€ ì—¬ë°±
      startAngle: 180, // ì‹œì‘ ê°ë„
      endAngle: 360, // ë ê°ë„
      label: "ë‚´ í•™ìŠµ vs íšŒì‚¬ í‰ê· ",
      description: "ë‚´ í•™ìŠµ ì •ë„ë¥¼ íšŒì‚¬ í‰ê· ê³¼ í•œëˆˆì— ë¹„êµ",
      position: "bottom",
    },
    // ============================================
    {
      selector: ".keyword-area",
      padding: 20,
      borderRadius: 16,
      label: "ë‚˜ì˜ ê´€ì‹¬ í‚¤ì›Œë“œ + íšŒì‚¬ì¶”ì²œ í‚¤ì›Œë“œ",
      description: "í‚¤ì›Œë“œ ë²„íŠ¼ìœ¼ë¡œ ON/OFF, ë‚˜ì˜ ê´€ì‹¬ í‚¤ì›Œë“œ í¸ì§‘ê°€ëŠ¥",
      position: "bottom",
    },
    {
      selector: "#nextBtn",
      padding: 12,
      borderRadius: 12,
      label: "ì»¨í…ì¸  ë³€ê²½",
      description: "ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ë‹¤ìŒ ì»¨í…ì¸  í™•ì¸",
      position: "left",
    },
  ];

  // MultiGuide ì´ˆê¸°í™” í•¨ìˆ˜ (ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ë„ë¡)
  window.initMultiGuide = function() {
    if (window.multiGuide) {
      console.log("MultiGuideê°€ ì´ë¯¸ ì´ˆê¸°í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.");
      return;
    }

    window.multiGuide = new MultiGuide(guideTargets);
    console.log("ë©€í‹° ê°€ì´ë“œ ì´ˆê¸°í™” ì™„ë£Œ!");
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ìœ¼ë¡œ ê°€ì´ë“œ ì‹¤í–‰
    // ëª¨ë“  ë¦¬ì†ŒìŠ¤ì™€ ë Œë”ë§ì´ ì™„ë£Œëœ í›„ ì‹¤í–‰
    let retryCount = 0;
    const maxRetries = 50; // 200ms * 50 = 10ì´ˆ
    
    function autoShowGuide() {
      retryCount++;
      
      // í•„ìš”í•œ ìš”ì†Œë“¤ì´ ëª¨ë‘ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
      const requiredElements = guideTargets
        .map(target => {
          const el = document.querySelector(target.selector);
          return { target, element: el, found: el !== null };
        });
      
      const foundCount = requiredElements.filter(r => r.found).length;
      const missingSelectors = requiredElements.filter(r => !r.found).map(r => r.target.selector);
      
      console.log(`[MultiGuide] ìš”ì†Œ í™•ì¸ (${retryCount}íšŒì°¨): ${foundCount}/${guideTargets.length}`, {
        found: foundCount,
        total: guideTargets.length,
        missing: missingSelectors
      });
      
      // ìµœì†Œí•œ ì ˆë°˜ ì´ìƒì˜ ìš”ì†Œê°€ ìˆìœ¼ë©´ ì‹¤í–‰ (ë„ˆë¬´ ì—„ê²©í•˜ì§€ ì•Šê²Œ)
      const minRequiredElements = Math.max(3, Math.floor(guideTargets.length * 0.5));
      
      if (foundCount >= minRequiredElements) {
        // ê²Œì´ì§€ê°€ ìˆëŠ” ê²½ìš° ê²Œì´ì§€ ì´ˆê¸°í™” í™•ì¸ (ì„ íƒì )
        const gaugeTarget = guideTargets.find(t => t.useGaugeArc);
        if (gaugeTarget) {
          const gaugeElement = document.getElementById("gauge");
          if (gaugeElement) {
            const hasGaugeContent = gaugeElement.children.length > 0 || 
                                   gaugeElement.querySelector('path') !== null ||
                                   gaugeElement.innerHTML.trim() !== '';
            
            if (!hasGaugeContent && retryCount < 20) {
              console.log("[MultiGuide] ê²Œì´ì§€ê°€ ì•„ì§ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ëŒ€ê¸° ì¤‘...");
              if (retryCount < maxRetries) {
                setTimeout(autoShowGuide, 200);
              }
              return;
            }
          }
        }
        
        // ê°€ì´ë“œ ì‹¤í–‰
        try {
          console.log("[MultiGuide] ê°€ì´ë“œ ì‹¤í–‰ ì‹œë„...");
          window.multiGuide.show();
          console.log("[MultiGuide] âœ… ë©€í‹° ê°€ì´ë“œ ìë™ ì‹¤í–‰ ì™„ë£Œ!");
        } catch (error) {
          console.error("[MultiGuide] âŒ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜:", error);
        }
      } else {
        // ìš”ì†Œê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì¬ì‹œë„
        if (retryCount < maxRetries) {
          console.log(`[MultiGuide] ìš”ì†Œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ì¬ì‹œë„ ì¤‘... (${retryCount}/${maxRetries})`);
          setTimeout(autoShowGuide, 200);
        } else {
          console.warn("[MultiGuide] âš ï¸ ìë™ ì‹¤í–‰ ì‹œê°„ ì´ˆê³¼. ì°¾ì§€ ëª»í•œ ìš”ì†Œ:", missingSelectors);
          console.warn("[MultiGuide] ìˆ˜ë™ìœ¼ë¡œ ì‹¤í–‰í•˜ë ¤ë©´: window.multiGuide.show()");
          
          // ê·¸ë˜ë„ ì‹¤í–‰ ì‹œë„ (ì¼ë¶€ ìš”ì†Œë§Œ ìˆì–´ë„)
          if (foundCount > 0) {
            try {
              console.log("[MultiGuide] ì¼ë¶€ ìš”ì†Œë§Œìœ¼ë¡œ ê°€ì´ë“œ ì‹¤í–‰ ì‹œë„...");
              window.multiGuide.show();
            } catch (error) {
              console.error("[MultiGuide] ì‹¤í–‰ ì‹¤íŒ¨:", error);
            }
          }
        }
      }
    }

    // window.load ì´ë²¤íŠ¸ë¥¼ ê¸°ë‹¤ë¦° í›„ ì‹¤í–‰
    if (document.readyState === "complete") {
      setTimeout(autoShowGuide, 1000);
    } else {
      window.addEventListener("load", () => {
        setTimeout(autoShowGuide, 1000);
      });
    }
  };

  // ìë™ ì´ˆê¸°í™”ëŠ” index_guide.htmlì—ì„œ ê²Œì´ì§€ ì´ˆê¸°í™” í›„ í˜¸ì¶œ
  // ì—¬ê¸°ì„œëŠ” í•¨ìˆ˜ë§Œ ì •ì˜í•˜ê³ , ì™¸ë¶€ì—ì„œ í˜¸ì¶œí•˜ë„ë¡ í•¨
</script>
