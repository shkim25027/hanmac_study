<button class="guide-btn guide-btn-start guide-start-btn" id="guideStart">
  ì‹œì‘í•˜ê¸°
</button>
<div class="guide-wrap">
  <svg class="guide-svg" width="100%" height="100%">
    <defs>
      <mask id="guide-mask">
        <rect x="0" y="0" width="100%" height="100%" fill="white" />
        <path id="guide-cutout-path" fill="black" />
      </mask>
    </defs>
    <rect
      x="0"
      y="0"
      width="100%"
      height="100%"
      fill="rgba(0, 0, 0, 0.5)"
      mask="url(#guide-mask)"
    />
  </svg>

  <div class="guide-mask nav"></div>
  <div class="guide-mask"></div>
</div>
<script>
  class MultiGuide {
    constructor(targets) {
      this.targets = targets;
      this.isActive = false;
      this.init();
    }

    init() {
      this.guideWrap = document.querySelector(".guide-wrap");
      this.cutoutPath = document.getElementById("guide-cutout-path");
      this.bordersContainer = document.getElementById("guideBorders");
      this.labelsContainer = document.getElementById("guideLabels");

      if (!this.bordersContainer) {
        this.bordersContainer = document.createElement("div");
        this.bordersContainer.id = "guideBorders";
        this.bordersContainer.className = "guide-borders";
        this.guideWrap.appendChild(this.bordersContainer);
      }

      if (!this.labelsContainer) {
        this.labelsContainer = document.createElement("div");
        this.labelsContainer.id = "guideLabels";
        this.labelsContainer.className = "guide-labels";
        this.labelsContainer.style.cssText =
          "position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10000;";
        this.guideWrap.appendChild(this.labelsContainer);
      }

      this.attachEvents();
    }

    getStartButton() {
      return (
        document.querySelector(".guide-start-btn") ||
        document.getElementById("guideStart") ||
        document.querySelector("[data-guide-start]")
      );
    }

    attachEvents() {
      const startBtn = this.getStartButton();
      if (startBtn) {
        startBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.show();
        });
      }

      const svg = document.querySelector(".guide-svg");
      if (svg) {
        svg.addEventListener("click", (e) => {
          if (e.target === svg || e.target.tagName.toLowerCase() === "rect") {
            this.hide();
          }
        });
      }

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && this.isActive) {
          this.hide();
        }
      });
    }

    show() {
      this.isActive = true;
      this.guideWrap.classList.add("active");

      const startBtn = this.getStartButton();
      if (startBtn) startBtn.style.display = "none";

      document.body.style.overflow = "hidden";

      this.createCutouts();
      this.createBorders();
      this.createLabels();
    }

    hide() {
      this.isActive = false;
      this.guideWrap.classList.remove("active");

      const startBtn = this.getStartButton();
      if (startBtn) startBtn.style.display = "block";

      document.body.style.overflow = "";

      if (this.bordersContainer) this.bordersContainer.innerHTML = "";
      if (this.labelsContainer) this.labelsContainer.innerHTML = "";
    }

    createCutouts() {
      let pathData = "";

      this.targets.forEach((target) => {
        const element = document.querySelector(target.selector);
        if (!element) {
          console.warn("ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:", target.selector);
          return;
        }

        // gauge SVGë¥¼ ê¸°ë°˜ìœ¼ë¡œ arc ê·¸ë¦¬ê¸°
        if (target.useGaugeArc) {
          pathData += this.createGaugeArcPath(element, target) + " ";
        }
        // ì¼ë°˜ arc
        else if (target.shape === "arc") {
          pathData +=
            this.createArcPath(
              element.getBoundingClientRect(),
              target.padding || 15,
              target
            ) + " ";
        }
        // ê¸°ë³¸ ì‚¬ê°í˜•
        else {
          const rect = element.getBoundingClientRect();
          const padding = target.padding || 15;
          const radius = target.borderRadius || 12;
          pathData +=
            this.createRoundedRectPath(
              rect.left - padding,
              rect.top - padding,
              rect.width + padding * 2,
              rect.height + padding * 2,
              radius
            ) + " ";
        }
      });

      this.cutoutPath.setAttribute("d", pathData.trim());
    }

    // ì‹¤ì œ ê²Œì´ì§€ ì„¤ì •ê°’ì„ ì‚¬ìš©í•œ arc path
    createGaugeArcPath(containerElement, target) {
      // gauge SVG ì°¾ê¸°
      const gaugeSvg = document.getElementById("gauge");
      if (!gaugeSvg) {
        console.warn("gauge SVGë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        return this.createArcPath(
          containerElement.getBoundingClientRect(),
          target.padding || 15,
          target
        );
      }

      // ê²Œì´ì§€ ì„¤ì •ê°’ (gauge.jsì™€ ë™ì¼)
      const size = target.gaugeSize || 832;
      const strokeWidth = target.gaugeStrokeWidth || 31;
      const padding = target.gaugePadding || 20;

      // ì‹¤ì œ ë°˜ì§€ë¦„ ê³„ì‚° (gauge.jsì™€ ë™ì¼)
      const center = size / 2;
      const radius = size / 2 - strokeWidth / 2 - padding;

      // SVGì˜ í™”ë©´ìƒ ìœ„ì¹˜ì™€ í¬ê¸°
      const svgRect = gaugeSvg.getBoundingClientRect();

      // viewBox ì •ë³´
      const viewBox = gaugeSvg.viewBox.baseVal;
      const viewBoxWidth = viewBox.width;
      const viewBoxHeight = viewBox.height;

      // ìŠ¤ì¼€ì¼ ê³„ì‚°
      const scaleX = svgRect.width / viewBoxWidth;
      const scaleY = svgRect.height / viewBoxHeight;

      // ì¤‘ì‹¬ì  í™”ë©´ ì¢Œí‘œ ë³€í™˜
      const screenCenterX = svgRect.left + (center - viewBox.x) * scaleX;
      const screenCenterY = svgRect.top + (center - viewBox.y) * scaleY;

      // ë°˜ì§€ë¦„ í™”ë©´ ì¢Œí‘œ ë³€í™˜
      const screenRadius = radius * scaleX;
      const screenStrokeWidth = strokeWidth * scaleX;

      // arcì˜ ë‘ê»˜ (stroke + ì—¬ìœ )
      const arcThickness = screenStrokeWidth + (target.padding || 10) * 2;

      // ê°ë„ ì„¤ì • (ê¸°ë³¸: í•˜ë‹¨ ë°˜ì›)
      const startAngle = target.startAngle || 180;
      const endAngle = target.endAngle || 360;

      // ì™¸ë¶€/ë‚´ë¶€ ë°˜ì§€ë¦„
      const outerRadius = screenRadius + arcThickness / 2;
      const innerRadius = screenRadius - arcThickness / 2;

      // ê°ë„ë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ
      const startRad = (startAngle * Math.PI) / 180;
      const endRad = (endAngle * Math.PI) / 180;

      // ì™¸ë¶€ arc ì ë“¤
      const outerStartX = screenCenterX + outerRadius * Math.cos(startRad);
      const outerStartY = screenCenterY + outerRadius * Math.sin(startRad);
      const outerEndX = screenCenterX + outerRadius * Math.cos(endRad);
      const outerEndY = screenCenterY + outerRadius * Math.sin(endRad);

      // ë‚´ë¶€ arc ì ë“¤
      const innerStartX = screenCenterX + innerRadius * Math.cos(startRad);
      const innerStartY = screenCenterY + innerRadius * Math.sin(startRad);
      const innerEndX = screenCenterX + innerRadius * Math.cos(endRad);
      const innerEndY = screenCenterY + innerRadius * Math.sin(endRad);

      const largeArc = endAngle - startAngle > 180 ? 1 : 0;

      // ğŸ”¥ ë‘¥ê·¼ ëì„ ìœ„í•œ ë°˜ì§€ë¦„ (arc ë‘ê»˜ì˜ ì ˆë°˜)
      const capRadius = arcThickness / 2;

      // ë„ë„› ëª¨ì–‘ path + ì–‘ìª½ ëì— ì› ì¶”ê°€
      let pathData = `
        M ${outerStartX},${outerStartY}
        A ${outerRadius},${outerRadius} 0 ${largeArc} 1 ${outerEndX},${outerEndY}
        L ${innerEndX},${innerEndY}
        A ${innerRadius},${innerRadius} 0 ${largeArc} 0 ${innerStartX},${innerStartY}
        Z
      `;

      // ì‹œì‘ì  ë‘¥ê·¼ ìº¡ (ì›)
      const startCapCenterX = screenCenterX + screenRadius * Math.cos(startRad);
      const startCapCenterY = screenCenterY + screenRadius * Math.sin(startRad);
      pathData += `
        M ${startCapCenterX + capRadius},${startCapCenterY}
        A ${capRadius},${capRadius} 0 1 1 ${startCapCenterX - capRadius},${startCapCenterY}
        A ${capRadius},${capRadius} 0 1 1 ${startCapCenterX + capRadius},${startCapCenterY}
        Z
      `;

      // ëì  ë‘¥ê·¼ ìº¡ (ì›)
      const endCapCenterX = screenCenterX + screenRadius * Math.cos(endRad);
      const endCapCenterY = screenCenterY + screenRadius * Math.sin(endRad);
      pathData += `
        M ${endCapCenterX + capRadius},${endCapCenterY}
        A ${capRadius},${capRadius} 0 1 1 ${endCapCenterX - capRadius},${endCapCenterY}
        A ${capRadius},${capRadius} 0 1 1 ${endCapCenterX + capRadius},${endCapCenterY}
        Z
      `;

      return pathData;
    }

    // ì¼ë°˜ arc path (fallback)
    createArcPath(rect, padding, target) {
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const radius = rect.width / 2 + padding;
      const thickness = target.arcThickness || radius * 0.2;
      const startAngle = target.startAngle || 180;
      const endAngle = target.endAngle || 360;

      const outerRadius = radius;
      const innerRadius = radius - thickness;

      const startRad = (startAngle * Math.PI) / 180;
      const endRad = (endAngle * Math.PI) / 180;

      const outerStartX = centerX + outerRadius * Math.cos(startRad);
      const outerStartY = centerY + outerRadius * Math.sin(startRad);
      const outerEndX = centerX + outerRadius * Math.cos(endRad);
      const outerEndY = centerY + outerRadius * Math.sin(endRad);

      const innerStartX = centerX + innerRadius * Math.cos(startRad);
      const innerStartY = centerY + innerRadius * Math.sin(startRad);
      const innerEndX = centerX + innerRadius * Math.cos(endRad);
      const innerEndY = centerY + innerRadius * Math.sin(endRad);

      const largeArc = endAngle - startAngle > 180 ? 1 : 0;

      // ğŸ”¥ ë‘¥ê·¼ ëì„ ìœ„í•œ ë°˜ì§€ë¦„
      const capRadius = thickness / 2;

      // ë„ë„› ëª¨ì–‘ + ì–‘ìª½ ë ì›
      let pathData = `
        M ${outerStartX},${outerStartY}
        A ${outerRadius},${outerRadius} 0 ${largeArc} 1 ${outerEndX},${outerEndY}
        L ${innerEndX},${innerEndY}
        A ${innerRadius},${innerRadius} 0 ${largeArc} 0 ${innerStartX},${innerStartY}
        Z
      `;

      // ì‹œì‘ì  ë‘¥ê·¼ ìº¡
      const startCapX =
        centerX + (outerRadius - thickness / 2) * Math.cos(startRad);
      const startCapY =
        centerY + (outerRadius - thickness / 2) * Math.sin(startRad);
      pathData += `
        M ${startCapX + capRadius},${startCapY}
        A ${capRadius},${capRadius} 0 1 1 ${startCapX - capRadius},${startCapY}
        A ${capRadius},${capRadius} 0 1 1 ${startCapX + capRadius},${startCapY}
        Z
      `;

      // ëì  ë‘¥ê·¼ ìº¡
      const endCapX =
        centerX + (outerRadius - thickness / 2) * Math.cos(endRad);
      const endCapY =
        centerY + (outerRadius - thickness / 2) * Math.sin(endRad);
      pathData += `
        M ${endCapX + capRadius},${endCapY}
        A ${capRadius},${capRadius} 0 1 1 ${endCapX - capRadius},${endCapY}
        A ${capRadius},${capRadius} 0 1 1 ${endCapX + capRadius},${endCapY}
        Z
      `;

      return pathData;
    }

    createRoundedRectPath(x, y, width, height, radius) {
      return `
        M ${x + radius},${y}
        L ${x + width - radius},${y}
        Q ${x + width},${y} ${x + width},${y + radius}
        L ${x + width},${y + height - radius}
        Q ${x + width},${y + height} ${x + width - radius},${y + height}
        L ${x + radius},${y + height}
        Q ${x},${y + height} ${x},${y + height - radius}
        L ${x},${y + radius}
        Q ${x},${y} ${x + radius},${y}
        Z
      `;
    }

    createBorders() {
      this.targets.forEach((target, index) => {
        const element = document.querySelector(target.selector);
        if (!element) return;

        // arcëŠ” SVG borderë¡œ ê·¸ë¦¬ê¸°
        if (target.useGaugeArc || target.shape === "arc") {
          // this.createArcBorder(element, target, index);
          return;
        }

        // ì¼ë°˜ ìš”ì†Œë§Œ div border í‘œì‹œ
        const rect = element.getBoundingClientRect();
        const padding = target.padding || 15;

        const border = document.createElement("div");
        border.className = "guide-border";
        border.style.cssText = `
          left: ${rect.left - padding}px;
          top: ${rect.top - padding}px;
          width: ${rect.width + padding * 2}px;
          height: ${rect.height + padding * 2}px;
          animation-delay: ${index * 0.1}s;
        `;
        this.bordersContainer.appendChild(border);
      });
    }

    // arc ì „ìš© SVG ë³´ë”
    createArcBorder(element, target, index) {
      const gaugeSvg = document.getElementById("gauge");
      if (!gaugeSvg && !target.useGaugeArc) {
        return;
      }

      let screenCenterX, screenCenterY, screenRadius, arcThickness;

      if (gaugeSvg && target.useGaugeArc) {
        // ì‹¤ì œ ê²Œì´ì§€ ì„¤ì • ì‚¬ìš©
        const size = target.gaugeSize || 832;
        const strokeWidth = target.gaugeStrokeWidth || 31;
        const padding = target.gaugePadding || 20;

        const center = size / 2;
        const gaugeRadius = size / 2 - strokeWidth / 2 - padding;

        const svgRect = gaugeSvg.getBoundingClientRect();
        const viewBox = gaugeSvg.viewBox.baseVal;
        const scaleX = svgRect.width / viewBox.width;

        screenCenterX = svgRect.left + (center - viewBox.x) * scaleX;
        screenCenterY = svgRect.top + (center - viewBox.y) * scaleX;
        screenRadius = gaugeRadius * scaleX;
        const screenStrokeWidth = strokeWidth * scaleX;
        arcThickness = screenStrokeWidth + (target.padding || 10) * 2;
      } else {
        // fallback
        const rect = element.getBoundingClientRect();
        screenCenterX = rect.left + rect.width / 2;
        screenCenterY = rect.top + rect.height / 2;
        screenRadius = rect.width / 2;
        arcThickness = target.arcThickness || screenRadius * 0.2;
      }

      const startAngle = target.startAngle || 180;
      const endAngle = target.endAngle || 360;

      const outerRadius = screenRadius + arcThickness / 2;
      const innerRadius = screenRadius - arcThickness / 2;

      const startRad = (startAngle * Math.PI) / 180;
      const endRad = (endAngle * Math.PI) / 180;

      const outerStartX = screenCenterX + outerRadius * Math.cos(startRad);
      const outerStartY = screenCenterY + outerRadius * Math.sin(startRad);
      const outerEndX = screenCenterX + outerRadius * Math.cos(endRad);
      const outerEndY = screenCenterY + outerRadius * Math.sin(endRad);

      const innerStartX = screenCenterX + innerRadius * Math.cos(startRad);
      const innerStartY = screenCenterY + innerRadius * Math.sin(startRad);
      const innerEndX = screenCenterX + innerRadius * Math.cos(endRad);
      const innerEndY = screenCenterY + innerRadius * Math.sin(endRad);

      const largeArc = endAngle - startAngle > 180 ? 1 : 0;

      // SVG ìƒì„±
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.style.cssText = `
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      `;

      // ì™¸ë¶€ arc
      const outerArc = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const outerArcData = `
        M ${outerStartX},${outerStartY}
        A ${outerRadius},${outerRadius} 0 ${largeArc} 1 ${outerEndX},${outerEndY}
      `;
      outerArc.setAttribute("d", outerArcData);
      outerArc.setAttribute("fill", "none");
      outerArc.setAttribute("stroke", "#4A9EFF");
      outerArc.setAttribute("stroke-width", "3");

      // ë‚´ë¶€ arc
      const innerArc = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const innerArcData = `
        M ${innerStartX},${innerStartY}
        A ${innerRadius},${innerRadius} 0 ${largeArc} 1 ${innerEndX},${innerEndY}
      `;
      innerArc.setAttribute("d", innerArcData);
      innerArc.setAttribute("fill", "none");
      innerArc.setAttribute("stroke", "#4A9EFF");
      innerArc.setAttribute("stroke-width", "3");

      // ì‹œì‘ìª½ ë°˜ì› ìº¡ (ì±„ì›Œì§„ ì›)
      const startCapRadius = arcThickness / 2;
      const startCapCenterX = screenCenterX + screenRadius * Math.cos(startRad);
      const startCapCenterY = screenCenterY + screenRadius * Math.sin(startRad);

      const startCap = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle"
      );
      startCap.setAttribute("cx", startCapCenterX);
      startCap.setAttribute("cy", startCapCenterY);
      startCap.setAttribute("r", startCapRadius);
      startCap.setAttribute("fill", "#4A9EFF");
      startCap.setAttribute("stroke", "#4A9EFF");
      startCap.setAttribute("stroke-width", "3");

      // ëìª½ ë°˜ì› ìº¡ (ì±„ì›Œì§„ ì›)
      const endCapCenterX = screenCenterX + screenRadius * Math.cos(endRad);
      const endCapCenterY = screenCenterY + screenRadius * Math.sin(endRad);

      const endCap = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle"
      );
      endCap.setAttribute("cx", endCapCenterX);
      endCap.setAttribute("cy", endCapCenterY);
      endCap.setAttribute("r", startCapRadius);
      endCap.setAttribute("fill", "#4A9EFF");
      endCap.setAttribute("stroke", "#4A9EFF");
      endCap.setAttribute("stroke-width", "3");

      svg.appendChild(outerArc);
      svg.appendChild(innerArc);
      svg.appendChild(startCap);
      svg.appendChild(endCap);
      this.bordersContainer.appendChild(svg);
    }

    createLabels() {
      this.targets.forEach((target, index) => {
        if (!target.label) return;

        const element = document.querySelector(target.selector);
        if (!element) return;

        const rect = element.getBoundingClientRect();

        const label = document.createElement("div");
        label.className = "guide-label";
        label.textContent = target.label;
        label.style.cssText = `
          left: ${rect.left + rect.width / 2}px;
          top: ${rect.top - 40}px;
          transform: translateX(-50%);
          animation-delay: ${index * 0.1 + 0.3}s;
        `;

        this.labelsContainer.appendChild(label);
      });
    }
  }

  // ============================================
  // íƒ€ê²Ÿ ì„¤ì • - ì‹¤ì œ ê²Œì´ì§€ ì„¤ì • ë°˜ì˜
  // ============================================
  const guideTargets = [
    {
      selector: ".nav",
      padding: 20,
      borderRadius: 16,
      label: "í•™ìŠµ ë©”ë‰´",
    },
    {
      selector: ".input-group",
      padding: 15,
      borderRadius: 12,
      label: "ê²€ìƒ‰",
    },
    {
      selector: ".item-box",
      padding: 15,
      borderRadius: 12,
      label: "ì•Œë¦¼",
    },
    // ===== ì‹¤ì œ ê²Œì´ì§€ ì„¤ì •ì„ ì‚¬ìš©í•œ ì •í™•í•œ arc! =====
    {
      selector: ".learning-area", // ë˜ëŠ” gaugeì˜ ë¶€ëª¨ ì»¨í…Œì´ë„ˆ
      useGaugeArc: true, // ğŸ”¥ ì‹¤ì œ ê²Œì´ì§€ ì„¤ì • ì‚¬ìš©!
      gaugeSize: 832, // gauge.jsì˜ size
      gaugeStrokeWidth: 31, // gauge.jsì˜ strokeWidth
      gaugePadding: 20, // gauge.jsì˜ padding
      padding: 10, // ì¶”ê°€ ì—¬ë°±
      startAngle: 180, // ì‹œì‘ ê°ë„
      endAngle: 360, // ë ê°ë„
      label: "í•™ìŠµ ê²Œì´ì§€",
    },
    // ============================================
    {
      selector: ".keyword-area",
      padding: 20,
      borderRadius: 16,
      label: "í‚¤ì›Œë“œ ì„¤ì •",
    },
    {
      selector: "#nextBtn",
      padding: 12,
      borderRadius: 12,
      label: "ë‹¤ìŒ í˜ì´ì§€",
    },
  ];

  // ì´ˆê¸°í™”
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      window.multiGuide = new MultiGuide(guideTargets);
      console.log("ë©€í‹° ê°€ì´ë“œ ì´ˆê¸°í™” ì™„ë£Œ!");
    });
  } else {
    window.multiGuide = new MultiGuide(guideTargets);
    console.log("ë©€í‹° ê°€ì´ë“œ ì´ˆê¸°í™” ì™„ë£Œ!");
  }
</script>
